{
  "_args": [
    [
      {
        "raw": "@parcel/babylon-walk@2.0.0-rc.0",
        "scope": "@parcel",
        "escapedName": "@parcel%2fbabylon-walk",
        "name": "@parcel/babylon-walk",
        "rawSpec": "2.0.0-rc.0",
        "spec": "2.0.0-rc.0",
        "type": "version"
      },
      "C:\\Users\\robin\\Documents\\Openclassrooms\\P3_bonhoure_robin\\RobinBonhoure_3_06102021\\node_modules\\@parcel\\babel-ast-utils"
    ]
  ],
  "_from": "@parcel/babylon-walk@2.0.0-rc.0",
  "_hasShrinkwrap": false,
  "_id": "@parcel/babylon-walk@2.0.0-rc.0",
  "_inCache": true,
  "_location": "/@parcel/babylon-walk",
  "_nodeVersion": "14.17.3",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/babylon-walk_2.0.0-rc.0_1627968478317_0.0762751010311471"
  },
  "_npmUser": {
    "name": "devongovett",
    "email": "devongovett@gmail.com"
  },
  "_npmVersion": "lerna/3.20.2/node@v14.17.3+x64 (linux)",
  "_phantomChildren": {},
  "_requested": {
    "raw": "@parcel/babylon-walk@2.0.0-rc.0",
    "scope": "@parcel",
    "escapedName": "@parcel%2fbabylon-walk",
    "name": "@parcel/babylon-walk",
    "rawSpec": "2.0.0-rc.0",
    "spec": "2.0.0-rc.0",
    "type": "version"
  },
  "_requiredBy": [
    "/@parcel/babel-ast-utils"
  ],
  "_resolved": "https://registry.npmjs.org/@parcel/babylon-walk/-/babylon-walk-2.0.0-rc.0.tgz",
  "_shasum": "fda5b73fa4803cd4c835ec85230a6f8f9baec2d7",
  "_shrinkwrap": null,
  "_spec": "@parcel/babylon-walk@2.0.0-rc.0",
  "_where": "C:\\Users\\robin\\Documents\\Openclassrooms\\P3_bonhoure_robin\\RobinBonhoure_3_06102021\\node_modules\\@parcel\\babel-ast-utils",
  "author": {
    "name": "Timothy Gu",
    "email": "timothygu99@gmail.com"
  },
  "dependencies": {
    "@babel/types": "^7.12.13",
    "lodash.clone": "^4.5.0"
  },
  "description": "Lightweight Babylon AST traversal",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "integrity": "sha512-h/Gz+RQNbPUxHHd0TO1lm1QmLhKI+kgByXq8U9cIMhkoef8gN2BqwA8v1Dr3Cm2tbT1G9TUPPx1GUrN8uA44pQ==",
    "shasum": "fda5b73fa4803cd4c835ec85230a6f8f9baec2d7",
    "tarball": "https://registry.npmjs.org/@parcel/babylon-walk/-/babylon-walk-2.0.0-rc.0.tgz",
    "fileCount": 17,
    "unpackedSize": 75761,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhCNPeCRA9TVsSAnZWagAAWqAP/3fwLVEZCqdm/wqozFMb\nlR71OSWqgM35WlD2/5diq4QWNSL4ifSIfjAJC6Z6T1TA2thaWgJf1u1XGOxN\n5GU5ayt6UM8t0OYEWYSaa/Dg0R40w9xYYt+6DQ2ujzkIXc9lYxIG9Cng4WRq\njwT0ITbDvLsAj7ryH3GZ7lfr83LMExmmIZMz9h8p3YGkx/ehpD0SOeiQBRFT\nRiHCgFRT365snTLuTEeLUwGJzCVVVvTj/g7ftDmm1iVbqvox8SNv00rpOVp2\nWu18LC7acflKXZi4IaWlKlBlYH1Hr5p9h9xxPXmT7mEb7NP2huJOCdmNVDCZ\nbIz8pbjAGlY0MGFu+mvXNBW/IgtITKc2/jXmP68hKFJcDwzY6B0I9x1pLx4s\ntCxTUPwco6ebes1FaHX6GpCr6pSbJnm3UyW2uMzOrVxRt1QoYV6FRiOP8LL0\nxBoeYlFOAO6pBy3s/alWIkVV1jEs6ww3W2A9R+yVZlgwj6laKfviLEu0fQid\n2/e4yn3Y3g8qlcNfXYVzDFFe+c34qEm7iICDB6GN/zZYF347C1EZeedPka+q\nNWC18IAneTFfA8lHvn8KEhPrKq7dyPHhVCBN/VvMhjMdmJH/r2AHNXSWx5bV\nMQ1efzKGwdWOnK5G6dObekKMMCe68UlymDk0I2b8jOaYU4rdFZ8ls222fwEq\n+Wl/\r\n=dcAu\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">= 12.0.0"
  },
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/parcel"
  },
  "gitHead": "8fc248f1f8eeb4428f7abd768bd23111451b1903",
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "devongovett",
      "email": "devongovett@gmail.com"
    }
  ],
  "name": "@parcel/babylon-walk",
  "optionalDependencies": {},
  "publishConfig": {
    "access": "public"
  },
  "readme": "# babylon-walk\n\nLightweight AST traversal tools for [Babylon] ASTs.\n\nBabylon is the parser used by the [Babel] project, which supplies the wonderful [babel-traverse] module for walking Babylon ASTs. Problem is, babel-traverse is very heavyweight, as it is designed to supply utilities to make all sorts of AST transformations possible. For simple AST walking without transformation, babel-traverse brings a lot of overhead.\n\nThis module loosely implements the API of Acorn parser's [walk module], which is a lightweight AST walker for the ESTree AST format.\n\nIn my tests, babylon-walk's ancestor walker (the most complex walker provided by this module) is about 8 times faster than babel-traverse, if the visitors are cached and the same AST is used for all runs. It is about 16 times faster if a fresh AST is used every run.\n\n[![Dependency Status](https://img.shields.io/david/pugjs/babylon-walk.svg)](https://david-dm.org/pugjs/babylon-walk)\n[![NPM version](https://img.shields.io/npm/v/babylon-walk.svg)](https://www.npmjs.com/package/babylon-walk)\n\n[babylon]: https://github.com/babel/babylon\n[babel]: https://babeljs.io/\n[babel-traverse]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-babel-traverse\n[walk module]: https://github.com/ternjs/acorn#distwalkjs\n\n## Installation\n\n```sh\n$ npm install babylon-walk\n```\n\n## API\n\n```js\nvar walk = require('babylon-walk');\n```\n\n### walk.simple(node, visitors, state)\n\nDo a simple walk over the AST. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state)`, where `node` is the AST node, and `state` is the same `state` passed to `walk.simple`.\n\nWhen `walk.simple` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to [cache your visitors] and communicate state leveraging the `state` parameter. (One difference between the linked article and babylon-walk is that the state is only accessible through the `state` variable, never as `this`.)\n\nAll [babel-types] aliases (e.g. `Expression`) and the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) work.\n\n### walk.ancestor(node, visitors, state)\n\nDo a simple walk over the AST, but memoizing the ancestors of the node and making them available to the visitors. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state, ancestors)`, where `node` is the AST node, `state` is the same `state` passed to `walk.ancestor`, and `ancestors` is an array of ancestors to the node (with the outermost node being `[0]` and the current node being `[ancestors.length - 1]`). If `state` is not specified in the call to `walk.ancestor`, the `state` parameter will be set to `ancestors`.\n\nWhen `walk.ancestor` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to [cache your visitors] and communicate state leveraging the `state` parameter. (One difference between the linked article and babylon-walk is that the state is only accessible through the `state` variable, never as `this`.)\n\nAll [babel-types] aliases (e.g. `Expression`) and the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) work.\n\n### walk.recursive(node, visitors, state)\n\nDo a recursive walk over the AST, where the visitors are responsible for continuing the walk on the child nodes of their target node. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state, c)`, where `node` is the AST node, `state` is the same `state` passed to `walk.recursive`, and `c` is a function that takes a single node as argument and continues walking _that_ node. If no visitor for a node is provided, the default walker algorithm will still be used.\n\nWhen `walk.recursive` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to [cache your visitors] and communicate state leveraging the `state` parameter. (One difference between the linked article and babylon-walk is that the state is only accessible through the `state` variable, never as `this`.)\n\nUnlike other babylon-walk walkers, `walk.recursive` does not call the `exit` visitor, only the `enter` (the default) visitor, of a specific node type.\n\nAll [babel-types] aliases (e.g. `Expression`) and the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) work.\n\nIn the following example, we are trying to count the number of functions in the outermost scope. This means, that we can simply walk all the statements and increment a counter if it is a function declaration or expression, and then stop walking. Note that we do not specify a visitor for the `Program` node, and the default algorithm for walking `Program` nodes is used (which is what we want). Also of note is how I bring the `visitors` object outside of `countFunctions` so that the object can be cached to improve performance.\n\n```js\nimport * as t from 'babel-types';\nimport {parse} from 'babylon';\nimport * as walk from 'babylon-walk';\n\nconst visitors = {\n  Statement(node, state, c) {\n    if (t.isVariableDeclaration(node)) {\n      for (let declarator of node.declarations) {\n        // Continue walking the declarator\n        c(declarator);\n      }\n    } else if (t.isFunctionDeclaration(node)) {\n      state.counter++;\n    }\n  },\n\n  VariableDeclarator(node, state) {\n    if (t.isFunction(node.init)) {\n      state.counter++;\n    }\n  },\n};\n\nfunction countFunctions(node) {\n  const state = {\n    counter: 0,\n  };\n  walk.recursive(node, visitors, state);\n  return state.counter;\n}\n\nconst ast = parse(`\n  // Counts\n  var a = () => {};\n\n  // Counts\n  function b() {\n    // Doesn't count\n    function c() {\n    }\n  }\n\n  // Counts\n  const c = function d() {};\n`);\n\ncountFunctions(ast);\n// = 3\n```\n\n### walk.traverse(node, visitors, state)\n\nVisitors get called as `(path, state)`. Every `Path` has these methods (similar to `@babel/traverse`):\n\n- `skip()`\n- `replaceWith(node)`\n- `remove()`\n\n[babel-types]: https://github.com/babel/babel/tree/master/packages/babel-types\n[cache your visitors]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-optimizing-nested-visitors\n[visitors]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-visitors\n\n## Caveat\n\nFor those of you migrating from Acorn to Babylon, there are a few things to be aware of.\n\n1. The visitor caching suggestions do not apply to Acorn's walk module, but do for babylon-walk.\n\n2. babylon-walk does not provide any of the other functions Acorn's walk module provides (e.g. `make`, `findNode*`).\n\n3. babylon-walk does not use a `base` variable. The walker algorithm is the same as what babel-traverse uses.\n   - That means certain nodes that are not walked by Acorn, such as the `property` property of a non-computed `MemberExpression`, are walked by babylon-walk.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "source": "src/index.js",
  "version": "2.0.0-rc.0",
  "warnings": [
    {
      "code": "ENOTSUP",
      "required": {
        "node": ">= 12.0.0"
      },
      "pkgid": "@parcel/babylon-walk@2.0.0-rc.0"
    }
  ]
}
